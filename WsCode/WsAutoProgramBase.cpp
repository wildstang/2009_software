//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Wildstang
//  @ File Name : WsAutoProgramBase.cpp
//  @ Date : 2/8/2009
//  @ Author : 
//
//


#include "WsAutoProgramBase.h"
#include "WsDriveVector.h"
#include "WsDriveBaseCrabSingle.h"
#include "WsAccumulator.h"
#include "WsEscalator.h"
#include "WsElevator.h"
#include "WsShooter.h"
#include "Timer.h"

WsAutoProgramBase::WsAutoProgramBase()
{
    ap_driveBase = NULL;
    ap_accumulator = NULL;
    ap_escalator = NULL;
    ap_elevatorLeft = NULL;
    ap_elevatorRight = NULL;
    ap_shooter = NULL;
    ap_timer = new Timer();
    if(ap_timer != NULL)
    {
        ap_timer ->Stop();
    }
    a_timerStartFlag = true;
}

WsAutoProgramBase::~WsAutoProgramBase()
{
    if(ap_timer != NULL)
    {
        delete ap_timer;
    }
    ap_timer = NULL;
}

bool WsAutoProgramBase::run(void )
{
    bool done = true;
    turnOffDriveBase();
    turnOffAppendages();
    return done;
}

void WsAutoProgramBase::assignDriveBase(WsDriveBaseCrabSingle* p_driveBase)
{
    ap_driveBase = p_driveBase;
}

void WsAutoProgramBase::assignAccumulator(WsAccumulator* p_accum)
{
    ap_accumulator = p_accum;
}

void WsAutoProgramBase::assignEscalator(WsEscalator* p_esc)
{
    ap_escalator = p_esc;
}

void WsAutoProgramBase::assignElevators(WsElevator* p_elevLeft, WsElevator* p_elevRight)
{
    ap_elevatorLeft = p_elevLeft;
    ap_elevatorRight = p_elevRight;
}

void WsAutoProgramBase::assignShooter(WsShooter* p_shooter)
{
    ap_shooter = p_shooter;
}

void WsAutoProgramBase::turnOffDriveBase(void )
{
    WsDriveVector v(0,0);
    if(ap_driveBase != NULL)
    {
        ap_driveBase->setVector(&v);
        ap_driveBase->setManualSpeed(0);
        ap_driveBase->setTractionControlState(false);
    }
}

void WsAutoProgramBase::turnOffAppendages(void )
{
    if(ap_accumulator != NULL)
    {
        ap_accumulator->setState(WsAccumulator::ACCUM_STATE_OFF);
    }

    if(ap_escalator != NULL)
    {
        float front, back;
        ap_escalator->setSpeed(WsEscalator::a_escOff, WsEscalator::a_escOff, &front, &back);
    }

    if(ap_elevatorLeft != NULL)
    {
        ap_elevatorLeft->turnOff();
    }

    if(ap_elevatorRight != NULL)
    {
        ap_elevatorRight->turnOff();
    }

    if(ap_shooter != NULL)
    {
        ap_shooter->setState(WsShooter::SHOOTER_STATE_OFF);
    }
}

bool WsAutoProgramBase::delay(double delayTime, double* p_currentTime)
{
    double time = 0;
    bool done = false;

    if(ap_timer != NULL)
    {
        if (a_timerStartFlag == true)
        {
            ap_timer->Start();
            a_timerStartFlag = false;
        }

        time = ap_timer->Get();

        if(time > delayTime)
        {
            ap_timer->Stop();
            ap_timer->Reset();
            a_timerStartFlag = true;
            done = true;
        }

        *p_currentTime = time;
    }
    else
    {
        done = true;
    }

    return done;
}

bool WsAutoProgramBase::driveByTime(WsDriveVector* p_driveVector, float crabAngle,
                                    double driveTime, double* p_currentTime)
{
    if(ap_driveBase != NULL)
    {
        ap_driveBase->setVector(p_driveVector);
        ap_driveBase->setCrabAngle(crabAngle);
    }

    return delay(driveTime, p_currentTime);
}

bool WsAutoProgramBase::coastPointWheels(float crabAngle,
                                         double delayTime,
                                         double* p_currentTime)
{
    WsDriveVector v(0,0);

    return driveByTime(&v, crabAngle, delayTime, p_currentTime);
}
