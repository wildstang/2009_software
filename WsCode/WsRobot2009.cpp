//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Wildstang 2009
//  @ File Name : WsRobot2009.cpp
//  @ Date : 1/14/2009
//  @ Author : 
//
//


#include <taskLib.h>
#include <semLib.h>
#include <errno.h>

#include "WsRobot2009.h"
#include "Joystick.h"
#include "Gamepad.h"
#include "Jaguar.h"
#include "Victor.h"
#include "Task.h"
#include "DriverStation.h"
#include "DriverStationLCD.h"
#include "DigitalInput.h"
#include "DigitalOutput.h"
#include "AnalogChannel.h"
#include "WsControllerAxis.h"
#include "WsControllerButton.h"
#include "WsControllerPolarStick.h"
#include "WsControllerStickyButton.h"
#include "WsControllerMultiStickyButton.h"
#include "WsControllerAnalogButton.h"
#include "WsControllerButton.h"
#include "WsControlMethodCrab.h"
#include "WsMotorManager.h"
#include "WsSc.h"
#include "WsRelay.h"
#include "WsPot.h"
#include "WsCrabController.h"
#include "WsDriveBaseCrabSingle.h"
#include "WsDashboard.h"
#include "WsLogger.h"
#include "WsCalibration.h"
#include "WsPid.h"
#include "WsAccumulator.h"
#include "WsElevator.h"
#include "WsEscalator.h"
#include "WsShooter.h"
#include "WsAppendageControl.h"
#include "LogServer/logtask.h"
#include "WsEncoderManager.h"
#include "WsEncoder.h"
#include "WsTractionWheel.h"
#include "WsDsAnalog.h"
#include "WsAutonomousMgr.h"
#include "WsEncoderTask.h"
#include "WsDriverStationLED.h"

#define ENABLE_LOG_SERVER 0
#define OI_TEST 0

#if ENABLE_LOG_SERVER
Task g_logServerTask("LogServer", (FUNCPTR)log_task_main);
#endif

Task g_encoderTask("Encoder", (FUNCPTR)encoder_task_main);

void WsRobot2009::RobotInit(void )
{
    /* Called when the robot is first initialized; instantiate robot objects */
    GetWatchdog().SetExpiration(Watchdog::kDefaultWatchdogExpiration);
    ap_dashboard = WsDashboard::getInstance(m_ds);
    ap_dsLcd = DriverStationLCD::GetInstance();
    ap_calib = WsCalibration::getInstance();
    a_calibrationMode = false;
    a_crabCalibrationOn = false;
    a_tcState = false;

    ap_dsLockInLed = new WsDriverStationLED(1);
    ap_dsTractionLed = new WsDriverStationLED(2);
    ap_dsLED3 = new WsDriverStationLED(3);
    ap_dsLED4 = new WsDriverStationLED(4);

#if ENABLE_LOG_SERVER
    g_logServerTask.Start();
    ap_logger = WsLogger::getInstance();
#else
    ap_logger = NULL;
#endif

    /********************
     * Inputs
     ********************/
    ap_driveGamepad = new Gamepad(1);
    ap_appendageGamepad = new Gamepad(3);

    /***** Common controls on OI panel *****/
    /* create buttons & axes */
    ap_calibrateEnableButton = new WsControllerButton(2);
    ap_calibrateCrabPotLeftButton = new WsControllerButton(ap_driveGamepad, 1);
    ap_calibrateCrabPotMidButton = new WsControllerButton(ap_driveGamepad, 4);
    ap_calibrateCrabPotRightButton = new WsControllerButton(ap_driveGamepad, 3);

    ap_tractionDisableButton = new WsControllerButton(4);

    ap_autoProgSelector = new WsDsAnalog(3);
    ap_autoPositionSelector = new WsDsAnalog(4);
    ap_autoLockinSwitch = new WsControllerButton(1);

    /***** Driver controls *****/
    /* create buttons & axes */
    ap_driveAxisX = new WsControllerAxis(ap_driveGamepad, 3);
    ap_driveAxisY = new WsControllerAxis(ap_driveGamepad, 4);
    ap_driveStick = new WsControllerPolarStick(ap_driveAxisX, ap_driveAxisY);

    ap_turboButton    = new WsControllerButton(ap_driveGamepad, 8);
    ap_tractionToggleButton = new WsControllerButton(ap_driveGamepad, 7);
    ap_discoverEncodersButton = new WsControllerButton(ap_driveGamepad, 2);

    ap_crabAxisX = new WsControllerAxis(ap_driveGamepad, 1);
    ap_crabAxisY = new WsControllerAxis(ap_driveGamepad, 2);
    ap_crabStick = new WsControllerPolarStick(ap_crabAxisX, ap_crabAxisY);

    ap_crabDisableButton = new WsControllerButton(3);
    ap_crabManualButton  = new WsControllerButton(ap_driveGamepad, 2); // X
    ap_crabNudgeLeftButton = new WsControllerButton(ap_driveGamepad, 5); // L1
    ap_crabNudgeRightButton = new WsControllerButton(ap_driveGamepad, 6); // R1

    /* create control methods & assign buttons & axes */
    ap_controlMethodCrab = new WsControlMethodCrab();
    ap_controlMethodCrab->assignCrabStick(ap_crabStick);
    ap_controlMethodCrab->assignCrabDisableButton(ap_crabDisableButton);
    ap_controlMethodCrab->assignCrabManualButton(ap_crabManualButton);
    ap_controlMethodCrab->assignCrabNudgeButtons(ap_crabNudgeLeftButton, ap_crabNudgeRightButton);
    ap_controlMethodCrab->assignDriveStick(ap_driveStick);
    ap_controlMethodCrab->assignTurboButton(ap_turboButton);

    /***** Manipulator controls *****/
    /* create buttons & axes */
    ap_elevatorAxisX = new WsControllerAxis(ap_appendageGamepad, 1);
    ap_elevatorAxisY = new WsControllerAxis(ap_appendageGamepad, 2);
    ap_escalatorAxisX = new WsControllerAxis(ap_appendageGamepad, 3);
    ap_escalatorAxisY = new WsControllerAxis(ap_appendageGamepad, 4);

    ap_elevatorStick = new WsControllerPolarStick(ap_elevatorAxisX, ap_elevatorAxisY);
    ap_escalatorStick = new WsControllerPolarStick(ap_escalatorAxisX, ap_escalatorAxisY);
    ap_elevDisableButton = new WsControllerButton(5);

    ap_emptyCellSigButton = new WsControllerButton(6);

    ap_shooterOutFastButton = new WsControllerButton(ap_appendageGamepad, 5);
    ap_shooterOutSlowButton = new WsControllerButton(ap_appendageGamepad, 7);
    ap_shooterInButton = new WsControllerButton(ap_appendageGamepad, Gamepad::kDown); 

    ap_accumulatorOutButton = new WsControllerButton(ap_appendageGamepad, 6);
    ap_accumulatorInButton = new WsControllerButton(ap_appendageGamepad, 8);

    ap_accumLoadButton = new WsControllerButton(ap_appendageGamepad, 2);
    ap_downOutButton = new WsControllerButton(ap_appendageGamepad, 1);

    ap_raiseShootLeftButton = new WsControllerButton(ap_appendageGamepad, Gamepad::kLeft);
    ap_raiseShootBothButton = new WsControllerButton(ap_appendageGamepad, Gamepad::kUp);
    ap_raiseShootRightButton = new WsControllerButton(ap_appendageGamepad, Gamepad::kRight);

    /* create control methods & assign buttons & axes */
    ap_appendageControl = new WsAppendageControl();
    ap_appendageControl->assignElevatorStick(ap_elevatorStick);
    ap_appendageControl->assignElevatorDisableButton(ap_elevDisableButton);
    ap_appendageControl->assignEscalatorStick(ap_escalatorStick);
    ap_appendageControl->assignAccumulatorButtons(ap_accumulatorInButton,
                                                  ap_accumulatorOutButton);
    ap_appendageControl->assignShooterButtons(  ap_shooterInButton,
                                                ap_shooterOutFastButton,
                                                ap_shooterOutSlowButton);
    ap_appendageControl->assignAccumLoadButton(ap_accumLoadButton);

    ap_appendageControl->assignRaiseShootLeftButton(ap_raiseShootLeftButton);
    ap_appendageControl->assignRaiseShootRightButton(ap_raiseShootRightButton);
    ap_appendageControl->assignRaiseShootBothButton(ap_raiseShootBothButton);
    ap_appendageControl->assignDownOutButton(ap_downOutButton);

    /********************
     * Sensors
     ********************/
    ap_crabPot = new WsPot(1, 1);
    ap_encoderManager = new WsEncoderManager();

    ap_encoderFL = ap_encoderManager->getEncoder(WsEncoderManager::FRONT_LEFT);
    ap_encoderFR = ap_encoderManager->getEncoder(WsEncoderManager::FRONT_RIGHT);
    ap_encoderBL = ap_encoderManager->getEncoder(WsEncoderManager::BACK_LEFT);
    ap_encoderBR = ap_encoderManager->getEncoder(WsEncoderManager::BACK_RIGHT);

    ap_elevatorLimitRightTop = new DigitalInput(4, 1);
    ap_elevatorLimitRightBottom = new DigitalInput(4, 2);
    ap_elevatorLimitLeftTop = new DigitalInput(4, 3);
    ap_elevatorLimitLeftBottom = new DigitalInput(4, 4);

    /********************
     * PID Controllers
     ********************/
    if (ap_calib->isCompetitionRobot())
    {
      ap_crabPID = new WsPid(.013, .010, 0, 3);
    }
    else
    {
      ap_crabPID = new WsPid(.020, .020, 0, 3);
    }
    ap_crabPID->setMinDoneCycles(10);

    /********************
     * Outputs
     ********************/
    /* create speed controllers & relays */
    ap_scDriveFL = new Victor(3); // orange
    ap_scDriveFR = new Victor(1); // blue
    ap_scDriveBL = new Victor(4); // red
    ap_scDriveBR = new Victor(2); // green

    if (ap_calib->isCompetitionRobot())
    {
      printf("!!!!!! COMPETITION ROBOT\n");
      ap_scCrabL   = new Victor(5); // yellow
      ap_scCrabR   = new Victor(6); // grey
      ap_scEscalatorF  = new Victor(9);   // black
      ap_scEscalatorB  = new Victor(10);  // white
      ap_scShooter     = new Victor(8);   // brown
    }
    else
    {
      printf("!!!!!! PROTO ROBOT\n");
      ap_scCrabL   = new Jaguar(5); // yellow
      ap_scCrabR   = new Jaguar(6); // grey
      ap_scEscalatorF  = new Jaguar(9);   // black
      ap_scEscalatorB  = new Jaguar(10);  // white
      ap_scShooter     = new Jaguar(8);   // brown
    }

    ap_scAccumulator = new Victor(7);   // purple
    ap_rlyElevatorR  = new Relay(1);    // blue/white
    ap_rlyElevatorL  = new Relay(2);    // green/white

    ap_wScDriveFL = new WsTractionWheel(ap_scDriveFL, ap_encoderFL,
                                        WsTractionWheel::WHEEL_FL);
    ap_wScDriveFL->a_debug = false;
    ap_wScDriveFR = new WsTractionWheel(ap_scDriveFR, ap_encoderFR,
                                        WsTractionWheel::WHEEL_FR);
    ap_wScDriveFR->a_debug = false;
    ap_wScDriveBL = new WsTractionWheel(ap_scDriveBL, ap_encoderBL,
                                        WsTractionWheel::WHEEL_BL);
    ap_wScDriveBL->a_debug = false;
    ap_wScDriveBR = new WsTractionWheel(ap_scDriveBR, ap_encoderBR,
                                        WsTractionWheel::WHEEL_BR);
    ap_wScDriveBR->a_debug = false;
    ap_wScCrabL   = new WsSc(ap_scCrabL);
    ap_wScCrabR   = new WsSc(ap_scCrabR);

    ap_wScAccumulator = new WsSc(ap_scAccumulator);
    ap_wScEscalatorF  = new WsSc(ap_scEscalatorF);
    ap_wScEscalatorB  = new WsSc(ap_scEscalatorB);
    ap_wRlyElevatorL  = new WsRelay(ap_rlyElevatorL);
    ap_wRlyElevatorR  = new WsRelay(ap_rlyElevatorR);
    ap_wScShooter     = new WsSc(ap_scShooter);

    /* create robot output objects */
    ap_accumulator = new WsAccumulator(ap_wScAccumulator);
    ap_escalator = new WsEscalator(ap_wScEscalatorF, ap_wScEscalatorB);
    ap_elevatorL = new WsElevator(ap_wRlyElevatorL);
    ap_elevatorL->assignLimitSwitches(ap_elevatorLimitLeftTop,
                                      ap_elevatorLimitLeftBottom);
    ap_elevatorR = new WsElevator(ap_wRlyElevatorR);
    ap_elevatorR->assignLimitSwitches(ap_elevatorLimitRightTop,
                                      ap_elevatorLimitRightBottom);
    ap_shooter = new WsShooter(ap_wScShooter);

    ap_crabController = new WsCrabController(ap_wScCrabL, ap_wScCrabR, ap_crabPot);
    ap_crabController->assignPid(ap_crabPID);

    ap_driveBase = new WsDriveBaseCrabSingle(ap_wScDriveFL, ap_wScDriveBL,
                                             ap_wScDriveFR, ap_wScDriveBR,
                                             ap_crabController);


    /********************
     * Motor managers
     ********************/
    /* entire robot */
    ap_mmgrRobot = new WsMotorManager();
    ap_mmgrRobot->addOutput(ap_wScDriveFL);
    ap_mmgrRobot->addOutput(ap_wScDriveFR);
    ap_mmgrRobot->addOutput(ap_wScDriveBL);
    ap_mmgrRobot->addOutput(ap_wScDriveBR);
    ap_mmgrRobot->addOutput(ap_wScCrabL);
    ap_mmgrRobot->addOutput(ap_wScCrabR);

    /* drive base */
    ap_mmgrDriveBase = new WsMotorManager();
    ap_mmgrDriveBase->addOutput(ap_wScDriveFL);
    ap_mmgrDriveBase->addOutput(ap_wScDriveFR);
    ap_mmgrDriveBase->addOutput(ap_wScDriveBL);
    ap_mmgrDriveBase->addOutput(ap_wScDriveBR);
    ap_mmgrDriveBase->addOutput(ap_wScCrabL);
    ap_mmgrDriveBase->addOutput(ap_wScCrabR);

    /* appendages */

    /* robot leds */
    ap_emptyCellSigLed = new DigitalOutput(4, 8);

    /********************
     * Autonomous
     ********************/
    ap_autonMgr = new WsAutonomousMgr(ap_autoProgSelector, ap_autoPositionSelector, ap_autoLockinSwitch, ap_dsLockInLed);
    ap_autonMgr->assignDriveBase(ap_driveBase);
    ap_autonMgr->assignAccumulator(ap_accumulator);
    ap_autonMgr->assignEscalator(ap_escalator);
    ap_autonMgr->assignElevators(ap_elevatorL, ap_elevatorR);
    ap_autonMgr->assignShooter(ap_shooter);

    /********************
     * Start encoder task
     ********************/
    g_encoderSemaphore = semMCreate(SEM_DELETE_SAFE | SEM_INVERSION_SAFE |
        SEM_Q_PRIORITY);
    memset(&g_encoderData, 0, sizeof(g_encoderData));
    g_encoderTask.Start();
}

WsRobot2009::~WsRobot2009()
{
    delete ap_driveGamepad;
    ap_driveGamepad = NULL;

    delete ap_driveAxisX;
    ap_driveAxisX = NULL;

    delete ap_driveAxisY;
    ap_driveAxisY = NULL;

    delete ap_driveStick;
    ap_driveStick = NULL;

    delete ap_turboButton;
    ap_turboButton = NULL;

    delete ap_tractionToggleButton;
    ap_tractionToggleButton = NULL;

    delete ap_crabAxisX;
    ap_crabAxisX = NULL;

    delete ap_crabAxisY;
    ap_crabAxisY = NULL;

    delete ap_crabStick;
    ap_crabStick = NULL;

    delete ap_crabDisableButton;
    ap_crabDisableButton = NULL;

    delete ap_crabManualButton;
    ap_crabManualButton = NULL;

    delete ap_crabNudgeLeftButton;
    ap_crabNudgeLeftButton = NULL;

    delete ap_crabNudgeRightButton;
    ap_crabNudgeRightButton = NULL;

    delete ap_controlMethodCrab;
    ap_controlMethodCrab = NULL;

    delete ap_scDriveFL;
    ap_scDriveFL = NULL;

    delete ap_scDriveFR;
    ap_scDriveFR = NULL;

    delete ap_scDriveBL;
    ap_scDriveBL = NULL;

    delete ap_scDriveBR;
    ap_scDriveBR = NULL;

    delete ap_scCrabL;
    ap_scCrabL = NULL;

    delete ap_scCrabR;
    ap_scCrabR = NULL;

    delete ap_scAccumulator;
    ap_scAccumulator = NULL;

    delete ap_scEscalatorF;
    ap_scEscalatorF = NULL;

    delete ap_scEscalatorB;
    ap_scEscalatorB = NULL;

    delete ap_rlyElevatorL;
    ap_rlyElevatorL = NULL;

    delete ap_rlyElevatorR;
    ap_rlyElevatorR = NULL;

    delete ap_scShooter;
    ap_scShooter = NULL;

    delete ap_wScDriveFL;
    ap_wScDriveFL = NULL;

    delete ap_wScDriveFR;
    ap_wScDriveFR = NULL;

    delete ap_wScDriveBL;
    ap_wScDriveBL = NULL;

    delete ap_wScDriveBR;
    ap_wScDriveBR = NULL;

    delete ap_wScCrabL;
    ap_wScCrabL = NULL;

    delete ap_wScCrabR;
    ap_wScCrabR = NULL;

    delete ap_wScDriveFL;
    ap_wScDriveFL = NULL;

    delete ap_wScDriveFR;
    ap_wScDriveFR = NULL;

    delete ap_wScDriveBL;
    ap_wScDriveBL = NULL;

    delete ap_wScDriveBR;
    ap_wScDriveBR = NULL;

    delete ap_wScCrabL;
    ap_wScCrabL = NULL;

    delete ap_wScCrabR;
    ap_wScCrabR = NULL;

    delete ap_wScAccumulator;
    ap_wScAccumulator = NULL;

    delete ap_wScEscalatorF;
    ap_wScEscalatorF = NULL;

    delete ap_wScEscalatorB;
    ap_wScEscalatorB = NULL;

    delete ap_wRlyElevatorL;
    ap_wRlyElevatorL = NULL;

    delete ap_wRlyElevatorR;
    ap_wRlyElevatorR = NULL;

    delete ap_wScShooter;
    ap_wScShooter = NULL;

    delete ap_accumulator;
    ap_accumulator = NULL;

    delete ap_escalator;
    ap_escalator = NULL;

    delete ap_elevatorL;
    ap_elevatorL = NULL;

    delete ap_elevatorR;
    ap_elevatorR = NULL;

    delete ap_shooter;
    ap_shooter = NULL;

    delete ap_crabPot;
    ap_crabPot = NULL;

    delete ap_crabPID;
    ap_crabPID = NULL;

    delete ap_crabController;
    ap_crabController = NULL;

    delete ap_driveBase;
    ap_driveBase = NULL;

    delete ap_mmgrRobot;
    ap_mmgrRobot = NULL;

    delete ap_mmgrDriveBase;
    ap_mmgrDriveBase = NULL;

    delete ap_calibrateEnableButton;
    ap_calibrateEnableButton = NULL;

    delete ap_calibrateCrabPotLeftButton;
    ap_calibrateCrabPotLeftButton = NULL;

    delete ap_calibrateCrabPotMidButton;
    ap_calibrateCrabPotMidButton = NULL;

    delete ap_calibrateCrabPotRightButton;
    ap_calibrateCrabPotRightButton = NULL;

    delete ap_discoverEncodersButton;
    ap_discoverEncodersButton = NULL;

    delete ap_appendageGamepad;
    ap_appendageGamepad = NULL;

    delete ap_elevatorAxisX;
    ap_elevatorAxisX = NULL;

    delete ap_elevatorAxisY;
    ap_elevatorAxisY = NULL;

    delete ap_escalatorAxisX;
    ap_escalatorAxisX = NULL;

    delete ap_escalatorAxisY;
    ap_escalatorAxisY = NULL;

    delete ap_elevatorStick;
    ap_elevatorStick = NULL;

    delete ap_escalatorStick;
    ap_escalatorStick = NULL;

    delete ap_elevDisableButton;
    ap_elevDisableButton = NULL;

    delete ap_tractionDisableButton;
    ap_tractionDisableButton = NULL;

    delete ap_emptyCellSigButton;
    ap_emptyCellSigButton = NULL;

    delete ap_shooterOutFastButton;
    ap_shooterOutFastButton = NULL;

    delete ap_shooterOutSlowButton;
    ap_shooterOutSlowButton = NULL;

    delete ap_shooterInButton;
    ap_shooterInButton = NULL;

    delete ap_accumulatorOutButton;
    ap_accumulatorOutButton = NULL;

    delete ap_accumulatorInButton;
    ap_accumulatorInButton = NULL;

    delete ap_accumLoadButton;
    ap_accumLoadButton = NULL;

    delete ap_raiseShootLeftButton;
    ap_raiseShootLeftButton = NULL;

    delete ap_raiseShootBothButton;
    ap_raiseShootLeftButton = NULL;

    delete ap_raiseShootRightButton;
    ap_raiseShootLeftButton = NULL;

    delete ap_downOutButton;
    ap_downOutButton = NULL;

    delete ap_appendageControl;
    ap_appendageControl = NULL;

    delete ap_encoderFL;
    ap_encoderFL = NULL;

    delete ap_encoderFR;
    ap_encoderFR = NULL;

    delete ap_encoderBL;
    ap_encoderBL = NULL;

    delete ap_encoderBR;
    ap_encoderBR = NULL;

    delete ap_autoProgSelector;
    ap_autoProgSelector = NULL;

    delete ap_autoPositionSelector;
    ap_autoPositionSelector = NULL;

    delete ap_autoLockinSwitch;
    ap_autoLockinSwitch = NULL;

    delete ap_autonMgr;
    ap_autonMgr = NULL;

    delete ap_dsLockInLed;
    ap_dsLockInLed = NULL;

    delete ap_dsTractionLed;
    ap_dsTractionLed = NULL;

    delete ap_dsLED3;
    ap_dsLED3 = NULL;

    delete ap_dsLED4;
    ap_dsLED4 = NULL;

    delete ap_emptyCellSigLed;
    ap_emptyCellSigLed = NULL;

#if ENABLE_LOG_SERVER
    /* kill the log server task */
    if (g_log_task_die_flag == LOG_TASK_RUNNING)
    {
      g_log_task_die_flag = LOG_TASK_KILL;
      while (g_log_task_die_flag != LOG_TASK_DEAD)
      {
        taskDelay(10);
      }
    }
    g_logServerTask.Stop();
#endif
}

void WsRobot2009::DisabledInit(void )
{
    /* Called once when we transition into disabled */
    a_crabCalibrationOn = false;
    ap_controlMethodCrab->clearTurboState();
    a_tcState = false;
}

void WsRobot2009::AutonomousInit(void )
{
    /* Called once when we transition into autonomous */
    a_crabCalibrationOn = false;
    ap_autonMgr->beginAutonomous();
}

void WsRobot2009::TeleopInit(void )
{
    /* Called once when we transition into teleop */
    a_crabCalibrationOn = false;
    ap_dsLockInLed->turnOff();

}

void WsRobot2009::DisabledPeriodic(void )
{
    /* Called periodically while disabled */
    GetWatchdog().Feed();

    /* Dashboard reset should be the first thing done after feeding watchdog */
    ap_dashboard->resetValues();
    ap_dashboard->setValue(IDX_CONTINUOUS_LOOP_COUNT,
        (UINT32)a_continuousLoopCounter);
    a_continuousLoopCounter = 0;

    dashboardDisplayInputs();

    if(IsDisabled())
    {
        ap_autonMgr->processLockin();
    }

    DriverStation *p_ds = DriverStation::GetInstance();

#if OI_TEST
    runOiTest();
#endif

    ap_wScDriveFL->ReadEncoders();
    ap_wScDriveFR->ReadEncoders();
    ap_wScDriveBL->ReadEncoders();
    ap_wScDriveBR->ReadEncoders();

    if (p_ds->IsAutonomous())
    {
        WsAutonomousMgr::StartingPositionT position;
        int progNum;
        //char *progName = "Sleeper";
        char autonString[21];
        char progName[PROG_NAME_LEN];
        bool lockState;

        memset(progName, 0, PROG_NAME_LEN);
        memset(autonString, 0, 21);

        position = ap_autonMgr->getPosition();
        progNum = ap_autonMgr->getProgNum();
        ap_autonMgr->getProgName(progName);
        lockState = ap_autonMgr->getLockState();
        snprintf(autonString, 21, "(%d,%d) %-10s",
                                   position, progNum, progName);


        ap_dsLcd->ClearBuffer();
        ap_dsLcd->Printf(DriverStationLCD::kMain_Line6, 1, "%s L:%d", autonString, lockState);
        ap_dsLcd->Printf(DriverStationLCD::kUser_Line2, 1, "Pos: %d", position);
        ap_dsLcd->Printf(DriverStationLCD::kUser_Line3, 1, "Prog: %d", progNum);
        ap_dsLcd->Printf(DriverStationLCD::kUser_Line4, 1, "Lock: %d", lockState);
        ap_dsLcd->Printf(DriverStationLCD::kUser_Line5, 1, "%-21s", autonString);
        ap_dsLcd->UpdateLCD();
    }
    else
    {
      if (processCalibration() == false)
      {
        printLcdRegularData();
      }
    }

    dashboardDisplaySensors();
    dashboardDisplayGeneral();

    ap_dashboard->update();
    //printf("\n");
}

void WsRobot2009::AutonomousPeriodic(void )
{
    /* Called periodically while autonomous */
    GetWatchdog().Feed();
    /* Dashboard reset should be the first thing done after feeding watchdog */
    ap_dashboard->resetValues();
    ap_dashboard->setValue(IDX_CONTINUOUS_LOOP_COUNT,
        (UINT32)a_continuousLoopCounter);
    a_continuousLoopCounter = 0;

    ap_autonMgr->run();

    // The dashboard update should be the last thing done in this function
    ap_dashboard->update();
}

void WsRobot2009::TeleopPeriodic(void )
{
    /* Called periodically while teleop */
    WsDriveVector v;
    float angle;
    float manualSpeed;

    GetWatchdog().Feed();

    /* Dashboard reset should be the first thing done after feeding watchdog */
    ap_dashboard->resetValues();
    ap_dashboard->setValue(IDX_CONTINUOUS_LOOP_COUNT,
        (UINT32)a_continuousLoopCounter);
    a_continuousLoopCounter = 0;

    dashboardDisplayInputs();

    /* don't run regular drive code if we're in discovery mode */
    if (discoverEncoders() == false)
    {
      /* enable / disable traction control */
      bool tcButton = ap_tractionToggleButton->getState();

      if ((ap_tractionDisableButton->getState() == true) ||
          (tcButton == true))
      {
        a_tcState = false;
        ap_dsTractionLed->turnOff();
      }
      else
      {
        a_tcState = true;
        ap_dsTractionLed->turnOn();
      }

      ap_driveBase->setTractionControlState(a_tcState);

      /*
       * Get drive base inputs & pass to drive base
       */
      if(ap_controlMethodCrab->getCrabEnableState() == true)
      {
        angle = ap_controlMethodCrab->getCrabWheelAngle();
        ap_driveBase->setCrabAngle(angle);
      }
      else
      {
        manualSpeed = ap_controlMethodCrab->getCrabManualSpeed();
        ap_driveBase->setManualSpeed(manualSpeed);
      }

      v = ap_controlMethodCrab->getDriveVector();
      ap_driveBase->setVector(&v);


      /*
       * Get appendage commands from inputs & pass to appendages
       */
      float accumSpeed;
      float escSpeedCmdF;
      float escSpeedCmdB;
      float escSpeedF;
      float escSpeedB;
      int elevSpeedL;
      int elevSpeedR;
      float shooterSpeed;

      WsAccumulator::WsAccumulatorStateT accumCommand;
      accumCommand = ap_appendageControl->getAccumulatorCommand();

      WsShooter::WsShooterStateT shooterCommand;
      shooterCommand = ap_appendageControl->getShooterCommand();

      WsElevator::WsElevatorStateT elevatorCommandL;
      elevatorCommandL = ap_appendageControl->getLeftElevatorCommand();

      WsElevator::WsElevatorStateT elevatorCommandR;
      elevatorCommandR = ap_appendageControl->getRightElevatorCommand();

      ap_appendageControl->getEscalatorSpeeds( &escSpeedCmdF, &escSpeedCmdB);

      accumSpeed = ap_accumulator->setState(accumCommand);

      ap_escalator->setSpeed(escSpeedCmdF, escSpeedCmdB, &escSpeedF, &escSpeedB);

      shooterSpeed = ap_shooter->setState(shooterCommand);


      ap_elevatorL->setUseLimitSwitches(ap_elevDisableButton->getState());
      elevSpeedL = ap_elevatorL->setState(elevatorCommandL);

      ap_elevatorR->setUseLimitSwitches(ap_elevDisableButton->getState());
      elevSpeedR = ap_elevatorR->setState(elevatorCommandR);

      //ap_emptyCellSigLed->Set(ap_emptyCellSigButton->GetState());
      //printf("CellSig: %d\n", ap_emptyCellSigButton->getState());

      ap_dashboard->setValue(IDX_OUT_ELEV_LEFT, (float)elevSpeedL);
      ap_dashboard->setValue(IDX_OUT_ELEV_RIGHT, (float)elevSpeedR);

      dashboardDisplaySensors();
      printLcdRegularData();
    }

    dashboardDisplayGeneral();

    // The dashboard update should be the last thing done in this function
    ap_dashboard->update();
}

void WsRobot2009::DisabledContinuous(void )
{
    /* Called every loop while disabled */
    a_continuousLoopCounter++;
}

void WsRobot2009::AutonomousContinuous(void )
{
    /* Called every loop while continuous */
    a_continuousLoopCounter++;
}


void WsRobot2009::TeleopContinuous(void )
{
    /* Called every loop while teleop */
    a_continuousLoopCounter++;
}

bool WsRobot2009::processCalibration(void)
{
    static UINT8 ledCounter = 0;
    //static bool ledOn = false;
    static bool prevCalibrationMode = false;
    static bool saveData = false;

    INT32 currentCrab;

    a_calibrationMode = ap_calibrateEnableButton->getState();

    currentCrab = ap_crabPot->GetAverageValue();

    if(currentCrab < 0)
    {
        currentCrab = 0;
    }

    if(a_calibrationMode == true)
    {
        ap_dsLcd->ClearBuffer();
        ap_dsLcd->Printf(DriverStationLCD::kUser_Line2, 1,
                         "Crab Calibration Mode");
        ap_dsLcd->Printf(DriverStationLCD::kUser_Line3, 1,
                         "        L   M   R ");
        ap_dsLcd->Printf(DriverStationLCD::kUser_Line4, 1,
                         "Saved: %3d %3d %3d",
                         ap_calib->getValue(WsCalibration::CRAB_LEFT),
                         ap_calib->getValue(WsCalibration::CRAB_MID),
                         ap_calib->getValue(WsCalibration::CRAB_RIGHT));
        ap_dsLcd->Printf(DriverStationLCD::kUser_Line5, 1,
                         "Curr:      %3d", currentCrab);

        if(ap_calibrateCrabPotLeftButton->getState() == true)
        {
            ap_calib->setValue(WsCalibration::CRAB_LEFT, currentCrab);
            saveData = true;
            ap_dsLcd->Printf(DriverStationLCD::kMain_Line6, 1,
                             "Crab Calib L: %3d", currentCrab);
            ap_dsLcd->Printf(DriverStationLCD::kUser_Line3, 1,
                             "       -L-        ");
            ap_dsLcd->Printf(DriverStationLCD::kUser_Line6, 1,
                             "L Calib Saved: %3d", currentCrab);
        }
        else if(ap_calibrateCrabPotMidButton->getState() == true)
        {
            ap_calib->setValue(WsCalibration::CRAB_MID, currentCrab);
            saveData = true;
            ap_dsLcd->Printf(DriverStationLCD::kMain_Line6, 1,
                             "Crab Calib M: %3d", currentCrab);
            ap_dsLcd->Printf(DriverStationLCD::kUser_Line3, 1,
                             "           -M-    ");
            ap_dsLcd->Printf(DriverStationLCD::kUser_Line6, 1,
                             "M Calib Saved: %3d", currentCrab);
        }
        else if(ap_calibrateCrabPotRightButton->getState() == true)
        {
            ap_calib->setValue(WsCalibration::CRAB_RIGHT, currentCrab);
            saveData = true;
            ap_dsLcd->Printf(DriverStationLCD::kMain_Line6, 1,
                             "Crab Calib R: %3d", currentCrab);
            ap_dsLcd->Printf(DriverStationLCD::kUser_Line3, 1,
                             "               -R-");
            ap_dsLcd->Printf(DriverStationLCD::kUser_Line6, 1,
                             "R Calib Saved: %3d", currentCrab);
        }
        else
        {
            ap_dsLcd->Printf(DriverStationLCD::kMain_Line6, 1,
                             "Crab Calib (Curr=%3d)", currentCrab);
        }
        ap_dsLcd->UpdateLCD();
    }

    if((saveData == true) &&
       (prevCalibrationMode != a_calibrationMode) &&
       (a_calibrationMode == false))
    {
        ap_calib->saveData();
        saveData = false;
        a_crabCalibrationOn = true;
    }

#if 1
    if(ledCounter < 50)
    {
        ledCounter++;
    }
    else
    {
        ledCounter = 0;
        a_crabCalibrationOn = false;
    }
#endif

    prevCalibrationMode = a_calibrationMode;

    return a_calibrationMode;
}

bool WsRobot2009::discoverEncoders()
{
  static bool prevDiscoverEncodersButton = false;
  static bool prevCalibrateEnableButton = false;
  static EncoderDiscoveryStateT state = DISCOVER_OFF;

  if (ap_calibrateEnableButton->getState() == true)
  {
    if (prevCalibrateEnableButton == false)
    {
      /* just entered discovery mode */
      state = DISCOVER_OFF;
      ap_encoderManager->discoverStart();
    }

    ap_dsLcd->ClearBuffer();
    ap_dsLcd->Printf(DriverStationLCD::kUser_Line2, 1, "Encoder Discovery");
    ap_dsLcd->Printf(DriverStationLCD::kUser_Line3, 1, "Left Front:  %d",
        ap_calib->getValue(WsCalibration::ENCODER_FL));
    ap_dsLcd->Printf(DriverStationLCD::kUser_Line4, 1, "Right Front: %d",
        ap_calib->getValue(WsCalibration::ENCODER_FR));
    ap_dsLcd->Printf(DriverStationLCD::kUser_Line5, 1, "Left Back:   %d",
        ap_calib->getValue(WsCalibration::ENCODER_BL));
    ap_dsLcd->Printf(DriverStationLCD::kUser_Line6, 1, "Right Back:  %d",
        ap_calib->getValue(WsCalibration::ENCODER_BR));

    switch(state)
    {
      case DISCOVER_OFF:
        ap_wScDriveFL->Set(0);
        ap_wScDriveFR->Set(0);
        ap_wScDriveBL->Set(0);
        ap_wScDriveBR->Set(0);
        ap_dsLcd->Printf(DriverStationLCD::kMain_Line6, 1, "Encoder Disc Ready");
        ap_dsLcd->Printf(DriverStationLCD::kUser_Line2, 1, "Encoder Discovery");
        if ((ap_discoverEncodersButton->getState() == true) &&
            (prevDiscoverEncodersButton == false))
        {
          state = DISCOVER_FL;
        }
        break;

      case DISCOVER_FL:
        ap_wScDriveFL->Set(1);
        ap_wScDriveFR->Set(0);
        ap_wScDriveBL->Set(0);
        ap_wScDriveBR->Set(0);
        ap_dsLcd->Printf(DriverStationLCD::kMain_Line6, 1, "Encoder Disc FL");
        ap_dsLcd->Printf(DriverStationLCD::kUser_Line2, 1, "Encoder Discovery FL");
        if(ap_encoderManager->discoverEncoder(WsEncoderManager::FRONT_LEFT) ==
            true)
        {
          state = DISCOVER_FL_DONE;
        }
        break;

      case DISCOVER_FL_DONE:
        ap_wScDriveFL->Set(0);
        ap_wScDriveFR->Set(0);
        ap_wScDriveBL->Set(0);
        ap_wScDriveBR->Set(0);
        ap_dsLcd->Printf(DriverStationLCD::kMain_Line6, 1, "Encoder Disc FL:%d",
                         ap_calib->getValue(WsCalibration::ENCODER_FL));
        ap_dsLcd->Printf(DriverStationLCD::kUser_Line2, 1, "Encoder Discovery FL");
        if ((ap_discoverEncodersButton->getState() == true) &&
            (prevDiscoverEncodersButton == false))
        {
          state = DISCOVER_FR;
        }
        break;

      case DISCOVER_FR:
        ap_wScDriveFL->Set(0);
        ap_wScDriveFR->Set(1);
        ap_wScDriveBL->Set(0);
        ap_wScDriveBR->Set(0);
        ap_dsLcd->Printf(DriverStationLCD::kMain_Line6, 1, "Encoder Disc FR");
        ap_dsLcd->Printf(DriverStationLCD::kUser_Line2, 1, "Encoder Discovery FR");
        if(ap_encoderManager->discoverEncoder(WsEncoderManager::FRONT_RIGHT) ==
           true)
        {
          state = DISCOVER_FR_DONE;
        }
        break;

      case DISCOVER_FR_DONE:
        ap_wScDriveFL->Set(0);
        ap_wScDriveFR->Set(0);
        ap_wScDriveBL->Set(0);
        ap_wScDriveBR->Set(0);
        ap_dsLcd->Printf(DriverStationLCD::kMain_Line6, 1, "Encoder Disc FR:%d",
                         ap_calib->getValue(WsCalibration::ENCODER_FR));
        ap_dsLcd->Printf(DriverStationLCD::kUser_Line2, 1, "Encoder Discovery FR");
        if ((ap_discoverEncodersButton->getState() == true) &&
            (prevDiscoverEncodersButton == false))
        {
          state = DISCOVER_BL;
        }
        break;

      case DISCOVER_BL:
        ap_wScDriveFL->Set(0);
        ap_wScDriveFR->Set(0);
        ap_wScDriveBL->Set(1);
        ap_wScDriveBR->Set(0);
        ap_dsLcd->Printf(DriverStationLCD::kMain_Line6, 1, "Encoder Disc BL");
        ap_dsLcd->Printf(DriverStationLCD::kUser_Line2, 1, "Encoder Discovery BL");
        if(ap_encoderManager->discoverEncoder(WsEncoderManager::BACK_LEFT) ==
           true)
        {
          state = DISCOVER_BL_DONE;
        }
        break;

      case DISCOVER_BL_DONE:
        ap_wScDriveFL->Set(0);
        ap_wScDriveFR->Set(0);
        ap_wScDriveBL->Set(0);
        ap_wScDriveBR->Set(0);
        ap_dsLcd->Printf(DriverStationLCD::kMain_Line6, 1, "Encoder Disc BL:%d",
                         ap_calib->getValue(WsCalibration::ENCODER_BL));
        ap_dsLcd->Printf(DriverStationLCD::kUser_Line2, 1, "Encoder Discovery BL");
        if ((ap_discoverEncodersButton->getState() == true) &&
            (prevDiscoverEncodersButton == false))
        {
          state = DISCOVER_BR;
        }
        break;

      case DISCOVER_BR:
        ap_wScDriveFL->Set(0);
        ap_wScDriveFR->Set(0);
        ap_wScDriveBL->Set(0);
        ap_wScDriveBR->Set(1);
        ap_dsLcd->Printf(DriverStationLCD::kMain_Line6, 1, "Encoder Disc BR");
        ap_dsLcd->Printf(DriverStationLCD::kUser_Line2, 1, "Encoder Discovery BR");
        if(ap_encoderManager->discoverEncoder(WsEncoderManager::BACK_RIGHT) ==
           true)
        {
          state = DISCOVER_DONE;
          /* Call discover done successfully */
          ap_encoderManager->discoverDone(true);
        }
        break;

      case DISCOVER_DONE:
        ap_wScDriveFL->Set(0);
        ap_wScDriveFR->Set(0);
        ap_wScDriveBL->Set(0);
        ap_wScDriveBR->Set(0);
        ap_dsLcd->Printf(DriverStationLCD::kMain_Line6, 1, "Encoder Disc Done");
        ap_dsLcd->Printf(DriverStationLCD::kUser_Line2, 1, "Encoder Discovery Dun");
        break;

      default:
        break;
    }
    ap_dsLcd->UpdateLCD();
  }
  else
  {
    /* call discover done unsuccessfully only once */
    if((prevCalibrateEnableButton == true) && (state != DISCOVER_DONE))
    {
      ap_encoderManager->discoverDone(false);
    }
    state = DISCOVER_OFF;
  }

  prevCalibrateEnableButton = ap_calibrateEnableButton->getState();
  prevDiscoverEncodersButton = ap_discoverEncodersButton->getState();

  return ap_calibrateEnableButton->getState();
}

void WsRobot2009::runOiTest(void)
{
    static int ledCounter = 0;
    static int currentLedOn = 1;

    /*
       printf("%d %d %d %d %d %d %d %d %8.3f %8.3f %8.3f %8.3f\n",
       p_ds->GetDigitalIn(1),
       p_ds->GetDigitalIn(2),
       p_ds->GetDigitalIn(3),
       p_ds->GetDigitalIn(4),
       p_ds->GetDigitalIn(5),
       p_ds->GetDigitalIn(6),
       p_ds->GetDigitalIn(7),
       p_ds->GetDigitalIn(8),
       p_ds->GetAnalogIn(1),
       p_ds->GetAnalogIn(2),
       p_ds->GetAnalogIn(3),
       p_ds->GetAnalogIn(4));
     */

    ap_dsLockInLed->turnOff();
    ap_dsTractionLed->turnOff();
    ap_dsLED3->turnOff();
    ap_dsLED4->turnOff();

    switch(currentLedOn)
    {
        case 1:
            ap_dsLockInLed->blink(10);
            break;
        case 2:
            ap_dsTractionLed->blink(10);
            break;
        case 3:
            ap_dsLED3->blink(10);
            break;
        case 4:
            ap_dsLED4->blink(10);
            break;
        default:
            break;
    }
#if 0
    ap_dsLockInLed->blink(.5);
    ap_dsLED2->blink(.25);
    ap_dsLED3->blink(1);
#endif

    if(ledCounter > 50)
    {
        ledCounter = 0;
        currentLedOn++;
        if(currentLedOn == 5)
        {
            currentLedOn = 1;
        }
    }
    else
    {
        ledCounter++;
    }
}

void WsRobot2009::dashboardDisplayInputs(void)
{
    if(ap_driveGamepad != NULL)
    {
        ap_dashboard->setValue(IDX_IN_DRIVE_X, ap_driveStick->getX());
        ap_dashboard->setValue(IDX_IN_DRIVE_Y, ap_driveStick->getY());
        ap_dashboard->setValue(IDX_IN_DRIVE_RADIUS, ap_driveStick->getRadius());
        ap_dashboard->setValue(IDX_IN_DRIVE_ANGLE, ap_driveStick->getAngle());
        ap_dashboard->setValue(IDX_IN_DRIVE_TURBO, ap_controlMethodCrab->getTurboState());
        ap_dashboard->setValue(IDX_IN_CRAB_X, ap_crabStick->getX());
        ap_dashboard->setValue(IDX_IN_CRAB_Y, ap_crabStick->getY());
        ap_dashboard->setValue(IDX_IN_CRAB_RADIUS, ap_crabStick->getRadius());
        ap_dashboard->setValue(IDX_IN_CRAB_ANGLE, ap_crabStick->getAngle());
    }

    if(ap_tractionToggleButton != NULL)
    {
        ap_dashboard->setValue(IDX_IN_DRIVE_TRACTION, ap_tractionToggleButton->getState());
    }

    if(ap_accumulatorInButton != NULL)
    {
        ap_dashboard->setValue(IDX_IN_ACCUM_IN,
                ap_accumulatorInButton->getState());
    }
    if(ap_accumulatorOutButton != NULL)
    {
        ap_dashboard->setValue(IDX_IN_ACCUM_OUT,
                ap_accumulatorOutButton->getState());
    }
    if(ap_accumLoadButton != NULL)
    {
        ap_dashboard->setValue(IDX_IN_ACCUM_LOAD,
                ap_accumLoadButton->getState());
    }

    if(ap_downOutButton != NULL)
    {
        ap_dashboard->setValue(IDX_IN_DOWN_OUT,
                ap_downOutButton->getState());
    }


    if(ap_shooterOutFastButton != NULL)
    {
        ap_dashboard->setValue(IDX_IN_SHOOT_OUT,
                ap_shooterOutFastButton->getState());
    }

    if(ap_shooterOutSlowButton != NULL)
    {
        ap_dashboard->setValue(IDX_IN_SHOOT_OUT_SLOW,
                ap_shooterOutSlowButton->getState());
    }

    if(ap_shooterInButton != NULL)
    {
        ap_dashboard->setValue(IDX_IN_SHOOT_IN,
                ap_shooterInButton->getState());
    }

    if(ap_elevatorStick != NULL)
    {
        ap_dashboard->setValue(IDX_IN_ELEV_X,
                ap_elevatorStick->getX());
        ap_dashboard->setValue(IDX_IN_ELEV_Y,
                ap_elevatorStick->getY());
        ap_dashboard->setValue(IDX_IN_ELEV_RADIUS,
                ap_elevatorStick->getRadius());
        ap_dashboard->setValue(IDX_IN_ELEV_ANGLE,
                ap_elevatorStick->getAngle());
    }

    if(ap_escalatorStick != NULL)
    {
        ap_dashboard->setValue(IDX_IN_ESC_X,
                ap_escalatorStick->getX());
        ap_dashboard->setValue(IDX_IN_ESC_Y,
                ap_escalatorStick->getY());
        ap_dashboard->setValue(IDX_IN_ESC_RADIUS,
                ap_escalatorStick->getRadius());
        ap_dashboard->setValue(IDX_IN_ESC_ANGLE,
                ap_escalatorStick->getAngle());
    }

    if(ap_raiseShootLeftButton != NULL)
    {
        ap_dashboard->setValue(IDX_IN_RAISE_SHOOT_LEFT,
                ap_raiseShootLeftButton->getState());
    }
    if(ap_raiseShootBothButton != NULL)
    {
        ap_dashboard->setValue(IDX_IN_RAISE_SHOOT_BOTH,
                ap_raiseShootBothButton->getState());
    }
    if(ap_raiseShootRightButton != NULL)
    {
        ap_dashboard->setValue(IDX_IN_RAISE_SHOOT_RIGHT,
                ap_raiseShootRightButton->getState());
    }
}

void WsRobot2009::dashboardDisplaySensors(void)
{
    INT32 currentCrab = 0;
    if(ap_crabPot != NULL)
    {
        currentCrab = ap_crabPot->GetAverageValue();
        if(currentCrab < 0)
        {
            currentCrab = 0;
        }
    }

    ap_dashboard->setValue(IDX_CALIBRATION_MODE, a_calibrationMode);

    ap_dashboard->setValue(IDX_POT_CRAB_CALIB_ACTIVE, a_crabCalibrationOn);
    ap_dashboard->setValue(IDX_POT_CRAB_CUR, (UINT32) currentCrab);
    ap_dashboard->setValue(IDX_POT_CRAB_CALIB_L, ap_calib->getValue(WsCalibration::CRAB_LEFT));
    ap_dashboard->setValue(IDX_POT_CRAB_CALIB_M, ap_calib->getValue(WsCalibration::CRAB_MID));
    ap_dashboard->setValue(IDX_POT_CRAB_CALIB_R, ap_calib->getValue(WsCalibration::CRAB_RIGHT));

    ap_dashboard->setValue(IDX_ENCODER_MODULE_FL, ap_calib->getValue(WsCalibration::ENCODER_FL));
    ap_dashboard->setValue(IDX_ENCODER_MODULE_FR, ap_calib->getValue(WsCalibration::ENCODER_FR));
    ap_dashboard->setValue(IDX_ENCODER_MODULE_BL, ap_calib->getValue(WsCalibration::ENCODER_BL));
    ap_dashboard->setValue(IDX_ENCODER_MODULE_BR, ap_calib->getValue(WsCalibration::ENCODER_BR));

    ap_dashboard->setValue(IDX_TRACTION_WHEELSPEED_FL, (float) ap_wScDriveFL->GetDrivenWheelSpeed());
    ap_dashboard->setValue(IDX_TRACTION_GROUNDSPEED_FL, (float) ap_wScDriveFL->GetIdlerWheelSpeed());
    ap_dashboard->setValue(IDX_TRACTION_SLIPRATIO_FL, (float) ap_wScDriveFL->GetSlipRatio());
    ap_dashboard->setValue(IDX_TRACTION_DES_OUTPUT_FL, ap_wScDriveFL->GetDesOutputSpeed());
    ap_dashboard->setValue(IDX_TRACTION_ACT_OUTPUT_FL, ap_wScDriveFL->GetActOutputSpeed());

    ap_dashboard->setValue(IDX_TRACTION_WHEELSPEED_FR, (float) ap_wScDriveFR->GetDrivenWheelSpeed());
    ap_dashboard->setValue(IDX_TRACTION_GROUNDSPEED_FR, (float) ap_wScDriveFR->GetIdlerWheelSpeed());
    ap_dashboard->setValue(IDX_TRACTION_SLIPRATIO_FR, (float) ap_wScDriveFR->GetSlipRatio());
    ap_dashboard->setValue(IDX_TRACTION_DES_OUTPUT_FR, ap_wScDriveFR->GetDesOutputSpeed());
    ap_dashboard->setValue(IDX_TRACTION_ACT_OUTPUT_FR, ap_wScDriveFR->GetActOutputSpeed());

    ap_dashboard->setValue(IDX_TRACTION_WHEELSPEED_BL, (float) ap_wScDriveBL->GetDrivenWheelSpeed());
    ap_dashboard->setValue(IDX_TRACTION_GROUNDSPEED_BL, (float) ap_wScDriveBL->GetIdlerWheelSpeed());
    ap_dashboard->setValue(IDX_TRACTION_SLIPRATIO_BL, (float) ap_wScDriveBL->GetSlipRatio());
    ap_dashboard->setValue(IDX_TRACTION_DES_OUTPUT_BL, ap_wScDriveBL->GetDesOutputSpeed());
    ap_dashboard->setValue(IDX_TRACTION_ACT_OUTPUT_BL, ap_wScDriveBL->GetActOutputSpeed());

    ap_dashboard->setValue(IDX_TRACTION_WHEELSPEED_BR, (float) ap_wScDriveBR->GetDrivenWheelSpeed());
    ap_dashboard->setValue(IDX_TRACTION_GROUNDSPEED_BR, (float) ap_wScDriveBR->GetIdlerWheelSpeed());
    ap_dashboard->setValue(IDX_TRACTION_SLIPRATIO_BR, (float) ap_wScDriveBR->GetSlipRatio());
    ap_dashboard->setValue(IDX_TRACTION_DES_OUTPUT_BR, ap_wScDriveBR->GetDesOutputSpeed());
    ap_dashboard->setValue(IDX_TRACTION_ACT_OUTPUT_BR, ap_wScDriveBR->GetActOutputSpeed());

    ap_dashboard->setValue(IDX_SW_ELEV_L_TOP, (bool)ap_elevatorLimitLeftTop->Get());
    ap_dashboard->setValue(IDX_SW_ELEV_L_BOT, (bool)ap_elevatorLimitLeftBottom->Get());
    ap_dashboard->setValue(IDX_SW_ELEV_R_TOP, (bool)ap_elevatorLimitRightTop->Get());
    ap_dashboard->setValue(IDX_SW_ELEV_R_BOT, (bool)ap_elevatorLimitRightBottom->Get());
}

void WsRobot2009::dashboardDisplayGeneral(void)
{
      ap_dashboard->setValue(IDX_TRACTION_ENABLE_STATE, a_tcState);
      if(ap_controlMethodCrab != NULL)
      {
          ap_dashboard->setValue(IDX_DES_CRAB_STATE,
                                ap_controlMethodCrab->getCrabEnableState());
      }
      else
      {
          ap_dashboard->setValue(IDX_DES_CRAB_STATE, false);
      }
}

void WsRobot2009::printLcdRegularData(void)
{
  UINT32 crabPos;
  DriverStation *p_ds = DriverStation::GetInstance();

  ap_dsLcd->ClearBuffer();

  crabPos = ap_crabPot->GetAverageValue();

  ap_dsLcd->Printf(DriverStationLCD::kMain_Line6, 1, "Crab pot: %3d",
      crabPos);
  ap_dsLcd->Printf(DriverStationLCD::kUser_Line2, 1, "Crab pot: %3d",
      crabPos);
  ap_dsLcd->Printf(DriverStationLCD::kUser_Line3, 1, "RT:%d RB:%d LT:%d LB:%d",
      ap_elevatorLimitRightTop->Get(),
      ap_elevatorLimitRightBottom->Get(),
      ap_elevatorLimitLeftTop->Get(),
      ap_elevatorLimitLeftBottom->Get());
  ap_dsLcd->Printf(DriverStationLCD::kUser_Line4, 1, "I F%3d,%3d B%3d,%3d",
      ap_wScDriveFL->GetIdlerWheelSpeed(),
      ap_wScDriveFR->GetIdlerWheelSpeed(),
      ap_wScDriveBL->GetIdlerWheelSpeed(),
      ap_wScDriveBR->GetIdlerWheelSpeed());
  ap_dsLcd->Printf(DriverStationLCD::kUser_Line5, 1, "D F%3d,%3d B%3d,%3d",
      ap_wScDriveFL->GetDrivenWheelSpeed(),
      ap_wScDriveFR->GetDrivenWheelSpeed(),
      ap_wScDriveBL->GetDrivenWheelSpeed(),
      ap_wScDriveBR->GetDrivenWheelSpeed());
  ap_dsLcd->Printf(DriverStationLCD::kUser_Line6, 1, "%4.0f %4.0f",
      p_ds->GetAnalogIn(3), p_ds->GetAnalogIn(4));
  ap_dsLcd->UpdateLCD();
}

