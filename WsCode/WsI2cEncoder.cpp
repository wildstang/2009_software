//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Wildstang
//  @ File Name : WsI2cEncoder.cpp
//  @ Date : 2/13/2009
//  @ Author : 
//
//


#include "WsI2cEncoder.h"
#include "DigitalModule.h"
#include "I2C.h"
#include "Utility.h"
#include "WPIStatus.h"

WsI2cEncoder::WsI2cEncoder(UINT32 slot, UINT8 addr) :
    WsEncoder(addr)
{
  ap_i2c = NULL;
  DigitalModule *module = DigitalModule::GetInstance(slot);
  ap_i2c = module->GetI2C(addr << 1);

  // Verify Sensor
  a_validEncoder = false;
  const UINT8 kExpectedManufacturer[] = "Wildstng";
  const UINT8 kExpectedSensorType[] = "Encoder ";

  if (!ap_i2c->VerifySensor(kManufacturerBaseRegister, kManufacturerSize,
                           kExpectedManufacturer))
  {
    printf("Error: encoder not manufactured by Wildstang; slot %d, "
        "address %d\n", slot, addr);
    return;
  }

  if (!ap_i2c->VerifySensor(kSensorTypeBaseRegister, kSensorTypeSize,
                           kExpectedSensorType))
  {
    printf("Error: wrong sensor type; slot %d, address %d\n", slot, addr);
    return;
  }

  a_validEncoder = true;
}


WsI2cEncoder::~WsI2cEncoder()
{
  delete ap_i2c;
  ap_i2c = NULL;
}

INT16 WsI2cEncoder::getDrivenWheelSpeed(void )
{
  if (a_validEncoder == true)
  {
    INT16 wheelSpeed;
    UINT8 readByte[2];

    ap_i2c->Read(kDrivenWheelSpeedRegister, 2, (UINT8 *)readByte);
    wheelSpeed = readByte[1] << 8;
    wheelSpeed |= readByte[0];
    return wheelSpeed;
  }
  else
  {
    return 0;
  }
}

INT16 WsI2cEncoder::getIdlerWheelSpeed(void )
{
  if (a_validEncoder == true)
  {
    INT16 wheelSpeed;
    UINT8 readByte[2];

    ap_i2c->Read(kIdlerWheelSpeedRegister, 2, (UINT8 *)readByte);
    wheelSpeed = readByte[1] << 8;
    wheelSpeed |= readByte[0];
    return wheelSpeed;
  }
  else
  {
    return 0;
  }
}

INT16 WsI2cEncoder::getSpeedDiff(void )
{
  if (a_validEncoder == true)
  {
    INT16 speedDiff;
    UINT8 readByte[2];

    ap_i2c->Read(kSpeedDiffRegister, 2, (UINT8 *)readByte);
    speedDiff = readByte[1] << 8;
    speedDiff |= readByte[0];
    return speedDiff;
  }
  else
  {
    return 0;
  }
}

INT16 WsI2cEncoder::getSlipRatio(void )
{
  if (a_validEncoder == true)
  {
    INT16 slipRatio;
    UINT8 readByte[2];

    ap_i2c->Read(kSlipRatioRegister, 2, (UINT8 *)readByte);
    slipRatio = readByte[1] << 8;
    slipRatio |= readByte[0];
    return slipRatio;
  }
  else
  {
    return 0;
  }
}

