//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Wildstang 2009
//  @ File Name : WsEncoderManager.cpp
//  @ Date : 2/5/2009
//  @ Author : 
//
//

//#include "vxWorks.h"
//#include "usrLib.h"


#include "WsEncoderManager.h"
#include "WsI2cEncoder.h"
#include "WsShmEncoder.h"
#include "WsCalibration.h"

#define SPEED_RANGE      100
#define DISCOVER_THRESH  20

WsEncoderManager::WsEncoderManager()
{
  ap_calib = WsCalibration::getInstance();
}

WsEncoderManager::~WsEncoderManager()
{
}

/*
 * If the configuration is valid, create a new WsI2cEncoder with the proper
 * address for the wheel position passed in and return it.  If the
 * configuration is invalid, return NULL.
 */
WsEncoder* WsEncoderManager::getEncoder(WsWheelPosT encoder)
{
  WsShmEncoder *p_encoder = NULL;
  bool invert;
  UINT8 address;

  if ((encoder == FRONT_RIGHT) || (encoder == BACK_RIGHT))
  {
    invert = true;
  }
  else
  {
    invert = false;
  }

  switch (encoder)
  {
    case FRONT_LEFT:
      address = ap_calib->getValue(WsCalibration::ENCODER_FL);
      p_encoder = new WsShmEncoder(address, invert);
      break;

    case FRONT_RIGHT:
#define HACK 0
#if HACK
      address = ap_calib->getValue(WsCalibration::ENCODER_FL);
      invert = false;
#else
      address = ap_calib->getValue(WsCalibration::ENCODER_FR);
#endif
      p_encoder = new WsShmEncoder(address, invert);

      break;

    case BACK_LEFT:
      address = ap_calib->getValue(WsCalibration::ENCODER_BL);
      p_encoder = new WsShmEncoder(address, invert);
      break;

    case BACK_RIGHT:
      address = ap_calib->getValue(WsCalibration::ENCODER_BR);
      p_encoder = new WsShmEncoder(address, invert);
      break;

    default:
      p_encoder = NULL;
      break;
  }

  return p_encoder;
}

void WsEncoderManager::discoverStart(void )
{
  UINT8 address;

  for (address = 1; address <= kMaxNumEncoders; address++)
  {
    ap_encoderArray[address - 1] = new WsShmEncoder(address, false);
    a_encoderLoopCountArray[address - 1] = 0;
  }
}

/*
 * This method is used to discover which encoder is attached to a wheel by
 * calling it when a single wheel is running full speed.  Call this method for
 * each wheel in sequence.
 *
 * Query all the encoders & determine which wheel is spinning.  If we are
 * confident which encoder is associated with the wheel, save the address in
 * the calibration data and return true.  Otherwise, return false.
 */
bool WsEncoderManager::discoverEncoder(WsWheelPosT wheel)
{
  UINT8 address;
  bool done = false;

  for (address = 1; address <= kMaxNumEncoders; address++)
  {
    /*
    printf("%d - %d  %d\n", address,
        ap_encoderArray[address - 1]->getDrivenWheelSpeed(),
        ap_encoderArray[address - 1]->getIdlerWheelSpeed());
    */

    if((ap_encoderArray[address - 1]->getDrivenWheelSpeed() > SPEED_RANGE) ||
       (ap_encoderArray[address - 1]->getDrivenWheelSpeed() < -SPEED_RANGE))
    {
      a_encoderLoopCountArray[address - 1]++;
    }

    if(a_encoderLoopCountArray[address - 1] > DISCOVER_THRESH)
    {
      switch(wheel)
      {
        case FRONT_LEFT:
          ap_calib->setValue(WsCalibration::ENCODER_FL, address);
          break;
        case FRONT_RIGHT:
          ap_calib->setValue(WsCalibration::ENCODER_FR, address);
          break;
        case BACK_LEFT:
          ap_calib->setValue(WsCalibration::ENCODER_BL, address);
          break;
        case BACK_RIGHT:
          ap_calib->setValue(WsCalibration::ENCODER_BR, address);
          break;
        default:
          break;
      }
      done = true;
    }
  }

  if (done == true)
  {
    for (address = 1; address <= kMaxNumEncoders; address++)
    {
      a_encoderLoopCountArray[address - 1] = 0;
    }
  }

  return done;
}

/*
 * Save the configuration to to a file.
 */
void WsEncoderManager::discoverDone(bool successful)
{
  UINT8 address;

  if (successful == true)
  {
    ap_calib->saveData();
  }

  for (address = 1; address <= kMaxNumEncoders; address++)
  {
    delete ap_encoderArray[address - 1];
    ap_encoderArray[address - 1] = NULL;
  }

}

